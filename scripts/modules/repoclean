#!/usr/bin/env bash
set -eo pipefail

# Clean behavior:
# - AUTO_CLEAN_KERNEL=true  -> always clean anything under $TOP/kernel that is a git worktree
# - AUTO_CLEAN_REPOS=true   -> clean all repo projects listed in $TOP/.repo/project.list
: "${AUTO_CLEAN_KERNEL:=true}"
: "${AUTO_CLEAN_REPOS:=true}"

_clean_git_tree() {
  local dir="$1"
  [[ -d "$dir" ]] || return 0

  # Works for both ".git" file (gitdir pointer) and ".git" directory.
  git -C "$dir" rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 0

  git -C "$dir" reset --hard >/dev/null 2>&1 || true
  git -C "$dir" clean -fdx   >/dev/null 2>&1 || true
}

repoclean_kernel_top() {
  local top="$1"
  [[ "$AUTO_CLEAN_KERNEL" == "true" ]] || return 0

  local kdir="$top/kernel"
  [[ -d "$kdir" ]] || return 0

  echo "[repoclean] Cleaning kernel working trees under: $kdir"

  # Find any git worktrees inside kernel/** without assuming vendor/soc path.
  # Limit depth for speed; adjust if you have deeper layouts.
  declare -A seen=()

  while IFS= read -r -d '' git_marker; do
    local root
    root="$(dirname "$git_marker")"

    # Deduplicate in case find hits both file/dir patterns, or nested markers.
    [[ -n "${seen["$root"]+x}" ]] && continue
    seen["$root"]=1

    _clean_git_tree "$root"
  done < <(
    find "$kdir" \
      -maxdepth 6 \
      \( -type f -name .git -o -type d -name .git \) \
      -print0 2>/dev/null || true
  )
}

repoclean_top() {
  local top="$1"
  [[ -d "$top/.repo" ]] || return 0

  # Kernel clean is independent of repo project.list and device name.
  repoclean_kernel_top "$top"

  # Full repo clean (optional)
  [[ "$AUTO_CLEAN_REPOS" == "true" ]] || return 0

  local list="$top/.repo/project.list"
  [[ -f "$list" ]] || return 0

  echo "[repoclean] Cleaning all repo project working trees under: $top"

  while IFS= read -r proj; do
    [[ -n "$proj" ]] || continue
    [[ -d "$top/$proj" ]] || continue
    _clean_git_tree "$top/$proj"
  done < "$list"
}

repoclean_all() {
  # Run if either mode is enabled
  [[ "$AUTO_CLEAN_REPOS" == "true" || "$AUTO_CLEAN_KERNEL" == "true" ]] || return 0
  [[ -n "${SRC_DIR:-}" ]] || return 0
  [[ -d "$SRC_DIR" ]] || return 0

  # Layout often looks like: $SRC_DIR/LINEAGE_23_0/.repo
  while IFS= read -r -d '' repodir; do
    repoclean_top "$(dirname "$repodir")"
  done < <(find "$SRC_DIR" -maxdepth 3 -type d -name .repo -print0 2>/dev/null || true)
}
