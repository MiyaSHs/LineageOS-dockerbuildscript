#!/usr/bin/env bash
set -eo pipefail

userscripts_assert_exec_mount() {
  if command -v findmnt >/dev/null 2>&1; then
    local opts
    opts="$(findmnt -no OPTIONS -T "$USERSCRIPTS_DIR" 2>/dev/null || true)"
    if echo "$opts" | grep -qw noexec; then
      echo "ERROR: USERSCRIPTS_DIR is on a 'noexec' mount: $USERSCRIPTS_DIR"
      echo "Mount options: $opts"
      echo "Move this repo/workdir somewhere executable (or remount without noexec)."
      exit 3
    fi
  fi
}

userscripts_write_before_sh() {
  cat > "$USERSCRIPTS_DIR/before.sh" <<'EOF'
#!/usr/bin/env bash
set -eo pipefail

# Find repo top
TOP="$PWD"
if [[ ! -d "$TOP/.repo" ]]; then
  TOP="$(find /srv/src -maxdepth 6 -type d -name .repo -print -quit 2>/dev/null | xargs -r dirname)"
fi
if [[ -z "$TOP" || ! -d "$TOP/.repo" ]]; then
  echo "[before.sh] ERROR: Could not locate repo top (.repo). PWD=$PWD"
  echo "[before.sh] Contents of /srv/src:"
  ls -la /srv/src || true
  exit 2
fi
cd "$TOP"

# Inject custom system apps (if provided)
if [[ -d /srv/custom_apps/vendor/custom_apps ]]; then
  echo "[before.sh] Installing custom apps into vendor/custom_apps..."
  rm -rf "$TOP/vendor/custom_apps"
  mkdir -p "$TOP/vendor"
  cp -a /srv/custom_apps/vendor/custom_apps "$TOP/vendor/"
fi

: "${REPLACE_STOCK_FDROID:=false}"

if [[ "$REPLACE_STOCK_FDROID" == "true" && -d "$TOP/vendor/partner_gms" ]]; then
  echo "[before.sh] REPLACE_STOCK_FDROID=true -> removing stock FDroid modules + references (safe mode)."

  # 1) Remove references from makefiles/xml, but DO NOT touch the module dirs themselves
  remove_from_partner_gms() {
    local token="$1"
    local files

    files="$(grep -RIl \
      --include='*.mk' --include='*.xml' \
      --exclude-dir='FDroid' \
      --exclude-dir='F-Droid' \
      --exclude-dir='FDroidPrivilegedExtension' \
      --exclude-dir='F-DroidPrivilegedExtension' \
      "$token" "$TOP/vendor/partner_gms" 2>/dev/null || true)"

    [[ -n "$files" ]] || return 0

    while IFS= read -r f; do
      sed -i \
        -e "s/[[:space:]]\\b${token}\\b[[:space:]]*/ /g" \
        -e "s/[[:space:]]\\{2,\\}/ /g" \
        "$f" || true
    done <<<"$files"
  }

  remove_from_partner_gms "FDroid"
  remove_from_partner_gms "FDroidPrivilegedExtension"
  remove_from_partner_gms "F-Droid"
  remove_from_partner_gms "F-DroidPrivilegedExtension"

  # 2) Delete the module directories so Android.mk never gets parsed
  rm -rf \
    "$TOP/vendor/partner_gms/FDroid" \
    "$TOP/vendor/partner_gms/F-Droid" \
    "$TOP/vendor/partner_gms/FDroidPrivilegedExtension" \
    "$TOP/vendor/partner_gms/F-DroidPrivilegedExtension"

  echo "[before.sh] Stock FDroid directories removed."
fi

: "${ROOT_METHOD:=none}"
: "${KERNEL_OPT_PROFILE:=battery}"
: "${DEVICE_LIST:=}"
: "${PARALLEL_JOBS:=4}"

: "${INTEGRATE_SUSFS:=false}"
: "${SUSFS_REF:=}"
: "${SUSFS_KERNEL_VERSION:=}"
: "${SUSFS_REPO_URL:=https://github.com/ShirkNeko/susfs4ksu.git}"

# SukiSU patchset (best-effort)
: "${SUKISU_PATCH_REPO_URL:=https://github.com/SukiSU-Ultra/SukiSU_patch.git}"
: "${SUKISU_APPLY_PATCHSET:=true}"

# Kernel/root integration assumes a single device codename
if [[ "$DEVICE_LIST" == *","* || "$DEVICE_LIST" == *" "* ]]; then
  echo "[before.sh] Multiple devices in DEVICE_LIST='$DEVICE_LIST'. Kernel/root patching expects a single device build. Continuing without patching."
  exit 0
fi

DEVICE="$DEVICE_LIST"

locate_defconfig() {
  # Try common patterns first (GKI), then fall back to fuzzy matches
  local p
  for p in \
    "*/arch/arm64/configs/vendor/${DEVICE}_GKI.config" \
    "*/arch/arm64/configs/vendor/${DEVICE}.config" \
    "*/arch/arm64/configs/vendor/${DEVICE}_defconfig" \
    "*/arch/arm64/configs/${DEVICE}_defconfig"
  do
    local hit
    hit="$(find . -type f -path "$p" -print -quit 2>/dev/null || true)"
    [[ -n "$hit" ]] && { echo "$hit"; return 0; }
  done

  # Fuzzy: anything containing device + GKI
  local hit
  hit="$(find . -type f -path "*/arch/arm64/configs/*" 2>/dev/null \
    | awk -v d="$DEVICE" 'BEGIN{IGNORECASE=1} index($0,d)>0 && index($0,"gki")>0 {print; exit}')"
  [[ -n "$hit" ]] && { echo "$hit"; return 0; }

  # Fuzzy: anything containing device + defconfig
  hit="$(find . -type f -path "*/arch/arm64/configs/*" 2>/dev/null \
    | awk -v d="$DEVICE" 'BEGIN{IGNORECASE=1} index($0,d)>0 && index($0,"defconfig")>0 {print; exit}')"
  [[ -n "$hit" ]] && { echo "$hit"; return 0; }

  return 1
}

KCONF="$(locate_defconfig || true)"

# If missing, try to trigger roomservice + sync now (best effort)
if [[ -z "$KCONF" ]]; then
  echo "[before.sh] Defconfig not present yet. Running breakfast + repo sync to fetch device/kernel repos..."
  if [[ -f build/envsetup.sh ]]; then
    # shellcheck disable=SC1091
    source build/envsetup.sh
    breakfast "$DEVICE" || true
  else
    echo "[before.sh] WARNING: build/envsetup.sh not found; cannot run breakfast."
  fi

  repo sync -c -j"$PARALLEL_JOBS" --force-sync || true
  KCONF="$(locate_defconfig || true)"
fi

if [[ -z "$KCONF" ]]; then
  echo "[before.sh] ERROR: Could not find a defconfig for device '$DEVICE' under arch/arm64/configs/"
  echo "[before.sh] Debug: some config candidates:"
  find . -type f -path "*/arch/arm64/configs/*" -maxdepth 14 2>/dev/null | head -n 150 || true
  exit 3
fi

KERNEL_DIR="$(realpath "$(dirname "$KCONF")/../../../..")"
DEFCONFIG_PATH="$(realpath "$KCONF")"

echo "[before.sh] Repo top:      $TOP"
echo "[before.sh] Kernel dir:    $KERNEL_DIR"
echo "[before.sh] Defconfig:     $DEFCONFIG_PATH"
echo "[before.sh] Opt profile:   $KERNEL_OPT_PROFILE"
echo "[before.sh] Root method:   $ROOT_METHOD"
echo "[before.sh] SUSFS enabled: $INTEGRATE_SUSFS"
echo "[before.sh] SUSFS ref:     $SUSFS_REF"
echo "[before.sh] SUSFS repo:    $SUSFS_REPO_URL"

cd "$KERNEL_DIR"

git reset --hard
git clean -fdx

ensure_kconfig() {
  local key="$1"
  local val="$2"
  local file="$3"
  if grep -qE "^${key}=" "$file"; then
    sed -i "s/^${key}=.*/${key}=${val}/" "$file"
  elif grep -qE "^# ${key} is not set" "$file"; then
    sed -i "s/^# ${key} is not set/${key}=${val}/" "$file"
  else
    echo "${key}=${val}" >> "$file"
  fi
}

ensure_not_set() {
  local key="$1"
  local file="$2"
  if grep -qE "^${key}=" "$file"; then
    sed -i "s/^${key}=.*/# ${key} is not set/" "$file"
  elif ! grep -qE "^# ${key} is not set" "$file"; then
    echo "# ${key} is not set" >> "$file"
  fi
}

kconfig_has() {
  local sym="$1"
  grep -Rqs --include='Kconfig*' "^[[:space:]]*config[[:space:]]\\+${sym}\\b" . 2>/dev/null
}

# Safe patch apply (no partial applies). Tries fuzz=0 then fuzz=3.
patch_apply_safe() {
  local dir="$1"
  local patch_file="$2"
  local label="${3:-patch}"
  local fuzz

  for fuzz in 0 3; do
    if ( cd "$dir" && patch -p1 --dry-run --batch --forward --fuzz="$fuzz" < "$patch_file" >/dev/null 2>&1 ); then
      echo "[before.sh] Applying $label (fuzz=$fuzz): $(basename "$patch_file")"
      ( cd "$dir" && patch -p1 --batch --forward --fuzz="$fuzz" < "$patch_file" )
      return 0
    fi
  done

  echo "[before.sh] $label not applicable: $(basename "$patch_file")"
  return 1
}

apply_sukisu_patchset() {
  [[ "$SUKISU_APPLY_PATCHSET" == "true" ]] || return 0
  command -v git >/dev/null 2>&1 || return 0

  local tmp="/tmp/sukisu_patch.$$"
  rm -rf "$tmp"

  echo "[before.sh] Fetching SukiSU patchset..."
  if ! git clone --depth 1 "$SUKISU_PATCH_REPO_URL" "$tmp" >/dev/null 2>&1; then
    echo "[before.sh] WARNING: could not clone SukiSU_patch ($SUKISU_PATCH_REPO_URL). Skipping."
    rm -rf "$tmp" || true
    return 0
  fi

  # 1) syscall hooks patch (required if we enable CONFIG_KSU_SYSCALL_HOOK)
  local syscall_patch=""
  syscall_patch="$(find "$tmp" -type f -iname '*syscall*hook*.patch' -print -quit 2>/dev/null || true)"

  if [[ -n "$syscall_patch" ]]; then
    if patch_apply_safe "$KERNEL_DIR" "$syscall_patch" "SukiSU syscall_hooks"; then
      ensure_kconfig CONFIG_KSU_SYSCALL_HOOK y "$DEFCONFIG_PATH" || true
      echo "[before.sh] Enabled CONFIG_KSU_SYSCALL_HOOK (patch applied)."
    else
      ensure_not_set CONFIG_KSU_SYSCALL_HOOK "$DEFCONFIG_PATH" || true
      echo "[before.sh] Leaving CONFIG_KSU_SYSCALL_HOOK disabled (patch did not apply)."
    fi
  else
    ensure_not_set CONFIG_KSU_SYSCALL_HOOK "$DEFCONFIG_PATH" || true
    echo "[before.sh] syscall_hooks patch not found in SukiSU_patch; leaving CONFIG_KSU_SYSCALL_HOOK disabled."
  fi

  # 2) hide stuff patch (best-effort)
  local hide_patch=""
  hide_patch="$(find "$tmp" -type f -name '69_hide_stuff.patch' -print -quit 2>/dev/null || true)"
  if [[ -n "$hide_patch" ]]; then
    patch_apply_safe "$KERNEL_DIR" "$hide_patch" "SukiSU 69_hide_stuff" || true
  fi

  rm -rf "$tmp" || true
}

apply_kernel_profile() {
  local profile="$1"
  local cfg="$2"

  case "$profile" in
    none)
      echo "[before.sh] KERNEL_OPT_PROFILE=none -> skipping kernel optimization."
      return 0
      ;;

    battery)
      echo "[before.sh] Applying battery-leaning kernel optimizations..."

      ensure_kconfig CONFIG_LTO_CLANG y "$cfg"
      ensure_kconfig CONFIG_LTO_CLANG_THIN y "$cfg"
      ensure_not_set CONFIG_LTO_CLANG_FULL "$cfg"
      ensure_not_set CONFIG_LTO_NONE "$cfg"

      ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_SIZE y "$cfg"

      ensure_kconfig CONFIG_ZSMALLOC y "$cfg"
      ensure_kconfig CONFIG_ZRAM m "$cfg"
      ensure_kconfig CONFIG_CRYPTO_ZSTD y "$cfg"
      ensure_kconfig CONFIG_ZSTD_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_ZSTD_DECOMPRESS y "$cfg"

      ensure_kconfig CONFIG_MODULE_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_MODULE_COMPRESS_ZSTD y "$cfg"

      ensure_not_set CONFIG_DEBUG_INFO "$cfg"
      ensure_not_set CONFIG_GCOV_KERNEL "$cfg"
      ensure_not_set CONFIG_KASAN "$cfg"
      ensure_not_set CONFIG_KCSAN "$cfg"
      ensure_not_set CONFIG_KFENCE "$cfg"
      ensure_not_set CONFIG_DEBUG_KERNEL "$cfg"

      ensure_kconfig CONFIG_LD_DEAD_CODE_DATA_ELIMINATION y "$cfg" || true
      ensure_kconfig CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL y "$cfg" || true
      ;;

    balanced)
      echo "[before.sh] Applying balanced kernel optimizations..."

      ensure_kconfig CONFIG_LTO_CLANG y "$cfg"
      ensure_kconfig CONFIG_LTO_CLANG_THIN y "$cfg"
      ensure_not_set CONFIG_LTO_CLANG_FULL "$cfg"
      ensure_not_set CONFIG_LTO_NONE "$cfg"

      ensure_not_set CONFIG_CC_OPTIMIZE_FOR_SIZE "$cfg"
      ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE y "$cfg"

      ensure_kconfig CONFIG_ZSMALLOC y "$cfg"
      ensure_kconfig CONFIG_ZRAM m "$cfg"
      ensure_kconfig CONFIG_CRYPTO_ZSTD y "$cfg"
      ensure_kconfig CONFIG_ZSTD_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_ZSTD_DECOMPRESS y "$cfg"

      ensure_kconfig CONFIG_MODULE_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_MODULE_COMPRESS_ZSTD y "$cfg"

      ensure_kconfig CONFIG_LD_DEAD_CODE_DATA_ELIMINATION y "$cfg" || true
      ;;

    performance)
      echo "[before.sh] Applying performance kernel optimizations (ThinLTO + O3 if available)..."

      ensure_kconfig CONFIG_LTO_CLANG y "$cfg"
      ensure_kconfig CONFIG_LTO_CLANG_THIN y "$cfg"
      ensure_not_set CONFIG_LTO_CLANG_FULL "$cfg"
      ensure_not_set CONFIG_LTO_NONE "$cfg"

      ensure_not_set CONFIG_CC_OPTIMIZE_FOR_SIZE "$cfg"

      if kconfig_has CC_OPTIMIZE_FOR_PERFORMANCE_O3; then
        ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE_O3 y "$cfg"
        ensure_not_set CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE "$cfg"
      else
        ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE y "$cfg"
      fi

      ensure_kconfig CONFIG_MODULE_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_MODULE_COMPRESS_ZSTD y "$cfg"
      ensure_kconfig CONFIG_LD_DEAD_CODE_DATA_ELIMINATION y "$cfg" || true
      ;;

    *)
      echo "[before.sh] Unknown KERNEL_OPT_PROFILE='$profile' (expected none|battery|balanced|performance)"
      return 1
      ;;
  esac
}

apply_kernel_profile "$KERNEL_OPT_PROFILE" "$DEFCONFIG_PATH"

# ---- Root integration (optional) ----
if [[ "$ROOT_METHOD" == "none" ]]; then
  echo "[before.sh] ROOT_METHOD=none -> skipping root integration."
  exit 0
fi

case "$ROOT_METHOD" in
  kernelsu)
    echo "[before.sh] Integrating KernelSU..."
    curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
    ensure_kconfig CONFIG_KSU y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPROBES y "$DEFCONFIG_PATH" || true
    ;;
  kernelsu-next)
    echo "[before.sh] Integrating KernelSU Next..."
    curl -LSs "https://raw.githubusercontent.com/KernelSU-Next/KernelSU-Next/next/kernel/setup.sh" | bash -
    ensure_kconfig CONFIG_KSU y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPROBES y "$DEFCONFIG_PATH" || true
    ;;
  sukisu-ultra)
    echo "[before.sh] Integrating SukiSU Ultra..."
    curl -LSs "https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh" | bash -s builtin
    ensure_kconfig CONFIG_KSU y "$DEFCONFIG_PATH"

    # Apply SukiSU_patch patches (this fixes syscall-hook build failures)
    apply_sukisu_patchset
    ;;
  *)
    echo "[before.sh] Unknown ROOT_METHOD='$ROOT_METHOD'"
    exit 10
    ;;
esac

echo "[before.sh] Root integration done: $ROOT_METHOD"

# ---- SUSFS integration (optional) ----
if [[ "$INTEGRATE_SUSFS" == "true" ]]; then
  if [[ -z "$SUSFS_REF" ]]; then
    echo "[before.sh] INTEGRATE_SUSFS=true but SUSFS_REF is empty -> skipping SUSFS."
  else
    echo "[before.sh] Integrating SUSFS (ref=$SUSFS_REF)..."
    # shellcheck disable=SC1091
    source /srv/userscripts/susfs.sh
    apply_susfs "$KERNEL_DIR" "$DEFCONFIG_PATH" "$SUSFS_REF"
    echo "[before.sh] SUSFS integration done."
  fi
fi
EOF

  # Helper file: susfs.sh (universal patch selection + safe/atomic application)
  cat > "$USERSCRIPTS_DIR/susfs.sh" <<'EOF'
#!/usr/bin/env bash
set -eo pipefail

apply_susfs() {
  local kernel_dir="$1"
  local defconfig_path="$2"
  local susfs_ref="$3"

  : "${SUSFS_REPO_URL:=https://github.com/ShirkNeko/susfs4ksu.git}"
  : "${SUSFS_KERNEL_VERSION:=}"
  : "${ROOT_METHOD:=none}"

  if [[ -z "$susfs_ref" ]]; then
    echo "[susfs] SUSFS_REF is empty; skipping."
    return 0
  fi

  command -v git >/dev/null 2>&1 || { echo "[susfs] ERROR: git not found."; return 20; }
  command -v patch >/dev/null 2>&1 || { echo "[susfs] ERROR: patch not found."; return 21; }

  local tmp="/tmp/susfs4ksu.$$"
  rm -rf "$tmp"
  trap 'rm -rf "$tmp" >/dev/null 2>&1 || true' RETURN

  echo "[susfs] Cloning SUSFS repo: $SUSFS_REPO_URL (ref=$susfs_ref)"
  git clone --depth 1 --branch "$susfs_ref" "$SUSFS_REPO_URL" "$tmp"

  # Find KernelSU dir produced by root setup scripts
  local ksu_dir=""
  ksu_dir="$(find "$kernel_dir" -maxdepth 6 -type d -name KernelSU -print -quit 2>/dev/null || true)"
  if [[ -z "$ksu_dir" ]]; then
    echo "[susfs] ERROR: Could not find KernelSU directory under: $kernel_dir"
    return 22
  fi

  # Common dir (GKI kernels often use kernel_root/common). If missing, use kernel root.
  local common_dir="$kernel_dir/common"
  [[ -d "$common_dir" ]] || common_dir="$kernel_dir"

  reset_all() {
    echo "[susfs] Resetting kernel working tree(s) (cleanup after failure)..."
    ( cd "$kernel_dir" && git reset --hard >/dev/null 2>&1 || true )
    ( cd "$kernel_dir" && git clean -fdx >/dev/null 2>&1 || true )
    if [[ -d "$ksu_dir/.git" ]]; then
      ( cd "$ksu_dir" && git reset --hard >/dev/null 2>&1 || true )
      ( cd "$ksu_dir" && git clean -fdx >/dev/null 2>&1 || true )
    fi
  }

  # Detect kernel version for better matching (best effort)
  local kver="${SUSFS_KERNEL_VERSION}"
  if [[ -z "$kver" && "$susfs_ref" =~ ([0-9]+\.[0-9]+) ]]; then
    kver="${BASH_REMATCH[1]}"
  fi
  if [[ -z "$kver" && -f "$common_dir/Makefile" ]]; then
    local v p
    v="$(grep -E '^VERSION[[:space:]]*=' "$common_dir/Makefile" | head -n1 | awk -F= '{gsub(/[[:space:]]/,"",$2);print $2}')"
    p="$(grep -E '^PATCHLEVEL[[:space:]]*=' "$common_dir/Makefile" | head -n1 | awk -F= '{gsub(/[[:space:]]/,"",$2);print $2}')"
    if [[ -n "$v" && -n "$p" ]]; then
      kver="${v}.${p}"
    fi
  fi

  local and_token=""
  if [[ "$susfs_ref" =~ (android[0-9]+) ]]; then
    and_token="${BASH_REMATCH[1]}"
  fi

  # Decide whether to apply KernelSU-side SUSFS patch
  local apply_ksu_patch="true"
  if [[ "$ROOT_METHOD" == "sukisu-ultra" ]]; then
    apply_ksu_patch="false"
  fi

  # Find KernelSU SUSFS patch (if we plan to use it)
  local ksu_patch=""
  if [[ "$apply_ksu_patch" == "true" ]]; then
    ksu_patch="$(find "$tmp" -type f -name '10_enable_susfs_for_ksu.patch' -print -quit 2>/dev/null || true)"
    if [[ -z "$ksu_patch" ]]; then
      echo "[susfs] 10_enable_susfs_for_ksu.patch not found -> skipping KernelSU-side SUSFS patch"
      apply_ksu_patch="false"
    fi
  fi

  # Collect kernel patch candidates (supports names like 50_add_susfs_in_gki-android13-5.10.patch)
  local -a candidates=()
  while IFS= read -r -d '' f; do
    candidates+=( "$f" )
  done < <(find "$tmp" -type f -name '50_add_susfs*.patch' -print0 2>/dev/null || true)

  if (( ${#candidates[@]} == 0 )); then
    echo "[susfs] ERROR: Could not find any kernel patch matching 50_add_susfs*.patch"
    return 23
  fi

  # Pick best kernel patch by scoring
  local ref_lc kver_lc and_lc
  ref_lc="$(echo "$susfs_ref" | tr '[:upper:]' '[:lower:]')"
  kver_lc="$(echo "${kver:-}" | tr '[:upper:]' '[:lower:]')"
  and_lc="$(echo "${and_token:-}" | tr '[:upper:]' '[:lower:]')"

  local best="" best_score=-1

  for f in "${candidates[@]}"; do
    local base lc score
    base="$(basename "$f")"
    lc="$(echo "$base" | tr '[:upper:]' '[:lower:]')"
    score=0

    if [[ -n "$ref_lc" && "$lc" == *"$ref_lc"* ]]; then score=$((score + 1000)); fi
    if [[ -n "$kver_lc" && "$lc" == *"$kver_lc"* ]]; then score=$((score + 200)); fi
    if [[ -n "$and_lc" && "$lc" == *"$and_lc"* ]]; then score=$((score + 120)); fi
    [[ "$lc" == *"gki"* ]] && score=$((score + 30))
    [[ "$lc" == *"in_gki"* ]] && score=$((score + 15))
    score=$((score - ${#lc} / 50))

    if (( score > best_score )); then
      best_score=$score
      best="$f"
    fi
  done

  if [[ -z "$best" ]]; then
    echo "[susfs] ERROR: Failed to choose a SUSFS kernel patch."
    return 25
  fi

  echo "[susfs] KernelSU dir: $ksu_dir"
  echo "[susfs] Common dir:   $common_dir"
  echo "[susfs] Detected kernel: ${kver:-unknown} (ref=$susfs_ref  android=${and_token:-unknown})"
  if [[ "$apply_ksu_patch" == "true" ]]; then
    echo "[susfs] Using KernelSU patch: $(basename "$ksu_patch")"
  else
    echo "[susfs] Skipping KernelSU-side patch (ROOT_METHOD=$ROOT_METHOD)"
  fi
  echo "[susfs] Using kernel patch:   $(basename "$best") (score=$best_score)"

  # Copy overlays (if present) BEFORE dry-run, as patch may touch these files.
  if [[ -d "$tmp/kernel_patches/fs" ]]; then
    mkdir -p "$common_dir/fs"
    cp -af "$tmp/kernel_patches/fs/." "$common_dir/fs/"
  fi
  if [[ -d "$tmp/kernel_patches/include/linux" ]]; then
    mkdir -p "$common_dir/include/linux"
    cp -af "$tmp/kernel_patches/include/linux/." "$common_dir/include/linux/"
  fi

  # Atomic patch strategy:
  # 1) dry-run everything
  # 2) only if dry-run passes, apply for real
  if [[ "$apply_ksu_patch" == "true" ]]; then
    if ! ( cd "$ksu_dir" && patch -p1 --dry-run --batch --forward --fuzz=0 < "$ksu_patch" >/dev/null 2>&1 ); then
      echo "[susfs] ERROR: KernelSU SUSFS patch does not apply cleanly. Aborting to avoid dirty tree."
      reset_all
      return 30
    fi
  fi

  if ! ( cd "$common_dir" && patch -p1 --dry-run --batch --forward --fuzz=0 < "$best" >/dev/null 2>&1 ); then
    echo "[susfs] ERROR: Kernel SUSFS patch does not apply cleanly. Aborting to avoid dirty tree."
    reset_all
    return 31
  fi

  # Apply patches (safe now)
  if [[ "$apply_ksu_patch" == "true" ]]; then
    echo "[susfs] Applying KernelSU SUSFS patch..."
    ( cd "$ksu_dir" && patch -p1 --batch --forward --fuzz=0 < "$ksu_patch" )
  fi

  echo "[susfs] Applying kernel SUSFS patch..."
  ( cd "$common_dir" && patch -p1 --batch --forward --fuzz=0 < "$best" )

  # Android 14+ tip from upstream docs: remove protected exports files if present
  rm -f "$common_dir/android/abi_gki_protected_exports_aarch64" \
        "$common_dir/android/abi_gki_protected_exports_x86_64" 2>/dev/null || true

  # Enable minimal config
  if declare -F ensure_kconfig >/dev/null 2>&1 && [[ -f "$defconfig_path" ]]; then
    ensure_kconfig CONFIG_KSU_SUSFS y "$defconfig_path"
  fi
}
EOF

  chmod 0755 "$USERSCRIPTS_DIR/before.sh"
  chmod 0644 "$USERSCRIPTS_DIR/susfs.sh"

  userscripts_assert_exec_mount
  [[ -x "$USERSCRIPTS_DIR/before.sh" ]] || { echo "ERROR: before.sh is not executable"; exit 4; }
}
