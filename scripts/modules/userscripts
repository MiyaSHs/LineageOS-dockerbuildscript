#!/usr/bin/env bash
set -eo pipefail

userscripts_assert_exec_mount() {
  if command -v findmnt >/dev/null 2>&1; then
    local opts
    opts="$(findmnt -no OPTIONS -T "$USERSCRIPTS_DIR" 2>/dev/null || true)"
    if echo "$opts" | grep -qw noexec; then
      echo "ERROR: USERSCRIPTS_DIR is on a 'noexec' mount: $USERSCRIPTS_DIR"
      echo "Mount options: $opts"
      echo "Move this repo/workdir somewhere executable (or remount without noexec)."
      exit 3
    fi
  fi
}

userscripts_write_before_sh() {
  cat > "$USERSCRIPTS_DIR/before.sh" <<'EOF'
#!/usr/bin/env bash
set -eo pipefail

# Find repo top
TOP="$PWD"
if [[ ! -d "$TOP/.repo" ]]; then
  TOP="$(find /srv/src -maxdepth 6 -type d -name .repo -print -quit 2>/dev/null | xargs -r dirname)"
fi
if [[ -z "$TOP" || ! -d "$TOP/.repo" ]]; then
  echo "[before.sh] ERROR: Could not locate repo top (.repo). PWD=$PWD"
  echo "[before.sh] Contents of /srv/src:"
  ls -la /srv/src || true
  exit 2
fi
cd "$TOP"

# Inject custom system apps (if provided)
if [[ -d /srv/custom_apps/vendor/custom_apps ]]; then
  echo "[before.sh] Installing custom apps into vendor/custom_apps..."
  rm -rf "$TOP/vendor/custom_apps"
  mkdir -p "$TOP/vendor"
  cp -a /srv/custom_apps/vendor/custom_apps "$TOP/vendor/"
fi

: "${REPLACE_STOCK_FDROID:=false}"

# Best-effort attempt to remove FDroid / PrivExt that came from vendor/partner_gms
if [[ "$REPLACE_STOCK_FDROID" == "true" && -d "$TOP/vendor/partner_gms" ]]; then
  echo "[before.sh] REPLACE_STOCK_FDROID=true -> attempting to remove stock FDroid + PrivExt from vendor/partner_gms (best-effort)."

  remove_from_partner_gms() {
    local token="$1"
    # Only touch product/package list files (not module definitions)
    local files
    files="$(grep -RIl --include='*.mk' --include='*.xml' "$token" "$TOP/vendor/partner_gms" 2>/dev/null || true)"
    [[ -n "$files" ]] || return 0
    while IFS= read -r f; do
      # Remove token occurrences; keep file syntactically valid
      sed -i \
        -e "s/[[:space:]]\\b${token}\\b[[:space:]]*/ /g" \
        -e "s/[[:space:]]\\{2,\\}/ /g" \
        "$f" || true
    done <<<"$files"
  }

  # Common module names seen in partner_gms trees
  remove_from_partner_gms "FDroid"
  remove_from_partner_gms "FDroidPrivilegedExtension"
  remove_from_partner_gms "F-Droid"
  remove_from_partner_gms "F-DroidPrivilegedExtension"
fi

: "${ROOT_METHOD:=none}"
: "${KERNEL_OPT_PROFILE:=battery}"
: "${DEVICE_LIST:=}"
: "${PARALLEL_JOBS:=4}"

# Kernel/root integration assumes a single device codename
if [[ "$DEVICE_LIST" == *","* || "$DEVICE_LIST" == *" "* ]]; then
  echo "[before.sh] Multiple devices in DEVICE_LIST='$DEVICE_LIST'. Kernel/root patching expects a single device build. Continuing without patching."
  exit 0
fi

DEVICE="$DEVICE_LIST"
DEFCONFIG_NAME="${DEVICE}_GKI.config"

locate_defconfig() {
  find . -type f -path "*/arch/arm64/configs/vendor/${DEFCONFIG_NAME}" -print -quit 2>/dev/null || true
}

KCONF="$(locate_defconfig)"

# If missing, try to trigger roomservice + sync now (device-independent)
if [[ -z "$KCONF" ]]; then
  echo "[before.sh] Defconfig not present yet. Running breakfast + repo sync to fetch device/kernel repos..."
  if [[ -f build/envsetup.sh ]]; then
    # shellcheck disable=SC1091
    source build/envsetup.sh
    breakfast "$DEVICE" || true
  else
    echo "[before.sh] WARNING: build/envsetup.sh not found; cannot run breakfast."
  fi

  repo sync -c -j"$PARALLEL_JOBS" --force-sync || true
  KCONF="$(locate_defconfig)"
fi

if [[ -z "$KCONF" ]]; then
  echo "[before.sh] ERROR: Could not find ${DEFCONFIG_NAME} under arch/arm64/configs/vendor/"
  echo "[before.sh] Debug: any *_GKI.config under vendor configs?"
  find . -type f -path "*/arch/arm64/configs/vendor/*_GKI.config" -maxdepth 12 2>/dev/null | head -n 100 || true
  exit 3
fi

KERNEL_DIR="$(realpath "$(dirname "$KCONF")/../../../..")"
DEFCONFIG_PATH="$(realpath "$KCONF")"

echo "[before.sh] Repo top:    $TOP"
echo "[before.sh] Kernel dir:  $KERNEL_DIR"
echo "[before.sh] Defconfig:   $DEFCONFIG_PATH"
echo "[before.sh] Opt profile: $KERNEL_OPT_PROFILE"
echo "[before.sh] Root method: $ROOT_METHOD"

cd "$KERNEL_DIR"

git reset --hard
git clean -fdx

ensure_kconfig() {
  local key="$1"
  local val="$2"
  local file="$3"
  if grep -qE "^${key}=" "$file"; then
    sed -i "s/^${key}=.*/${key}=${val}/" "$file"
  elif grep -qE "^# ${key} is not set" "$file"; then
    sed -i "s/^# ${key} is not set/${key}=${val}/" "$file"
  else
    echo "${key}=${val}" >> "$file"
  fi
}

ensure_not_set() {
  local key="$1"
  local file="$2"
  if grep -qE "^${key}=" "$file"; then
    sed -i "s/^${key}=.*/# ${key} is not set/" "$file"
  elif ! grep -qE "^# ${key} is not set" "$file"; then
    echo "# ${key} is not set" >> "$file"
  fi
}

# Detect if a Kconfig symbol exists (so we can safely enable O3 if supported)
kconfig_has() {
  local sym="$1"
  grep -Rqs --include='Kconfig*' "^[[:space:]]*config[[:space:]]\\+${sym}\\b" . 2>/dev/null
}

apply_kernel_profile() {
  local profile="$1"
  local cfg="$2"

  case "$profile" in
    none)
      echo "[before.sh] KERNEL_OPT_PROFILE=none -> skipping kernel optimization."
      return 0
      ;;

    battery)
      echo "[before.sh] Applying battery-leaning kernel optimizations..."

      # ThinLTO (less RAM than full LTO; still increases link RAM vs no LTO)
      ensure_kconfig CONFIG_LTO_CLANG y "$cfg"
      ensure_kconfig CONFIG_LTO_CLANG_THIN y "$cfg"
      ensure_not_set CONFIG_LTO_CLANG_FULL "$cfg"
      ensure_not_set CONFIG_LTO_NONE "$cfg"

      # Size-leaning optimization (typically -Oz/-Os depending on tree/toolchain)
      ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_SIZE y "$cfg"

      # ZRAM + zstd support (userspace picks algorithm, but kernel must support it)
      ensure_kconfig CONFIG_ZSMALLOC y "$cfg"
      ensure_kconfig CONFIG_ZRAM m "$cfg"
      ensure_kconfig CONFIG_CRYPTO_ZSTD y "$cfg"
      ensure_kconfig CONFIG_ZSTD_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_ZSTD_DECOMPRESS y "$cfg"

      # Module compression
      ensure_kconfig CONFIG_MODULE_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_MODULE_COMPRESS_ZSTD y "$cfg"

      # Trim heavy debug (safe-ish for release builds)
      ensure_not_set CONFIG_DEBUG_INFO "$cfg"
      ensure_not_set CONFIG_GCOV_KERNEL "$cfg"
      ensure_not_set CONFIG_KASAN "$cfg"
      ensure_not_set CONFIG_KCSAN "$cfg"
      ensure_not_set CONFIG_KFENCE "$cfg"
      ensure_not_set CONFIG_DEBUG_KERNEL "$cfg"

      # Optional if present
      ensure_kconfig CONFIG_LD_DEAD_CODE_DATA_ELIMINATION y "$cfg" || true
      ensure_kconfig CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL y "$cfg" || true
      ;;

    balanced)
      echo "[before.sh] Applying balanced kernel optimizations..."

      ensure_kconfig CONFIG_LTO_CLANG y "$cfg"
      ensure_kconfig CONFIG_LTO_CLANG_THIN y "$cfg"
      ensure_not_set CONFIG_LTO_CLANG_FULL "$cfg"
      ensure_not_set CONFIG_LTO_NONE "$cfg"

      # Keep default perf (-O2)
      ensure_not_set CONFIG_CC_OPTIMIZE_FOR_SIZE "$cfg"
      ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE y "$cfg"

      ensure_kconfig CONFIG_ZSMALLOC y "$cfg"
      ensure_kconfig CONFIG_ZRAM m "$cfg"
      ensure_kconfig CONFIG_CRYPTO_ZSTD y "$cfg"
      ensure_kconfig CONFIG_ZSTD_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_ZSTD_DECOMPRESS y "$cfg"

      ensure_kconfig CONFIG_MODULE_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_MODULE_COMPRESS_ZSTD y "$cfg"

      ensure_kconfig CONFIG_LD_DEAD_CODE_DATA_ELIMINATION y "$cfg" || true
      ;;

    performance)
      echo "[before.sh] Applying performance kernel optimizations (ThinLTO + O3 if available)..."

      # Keep ThinLTO (your request), avoid full LTO OOM
      ensure_kconfig CONFIG_LTO_CLANG y "$cfg"
      ensure_kconfig CONFIG_LTO_CLANG_THIN y "$cfg"
      ensure_not_set CONFIG_LTO_CLANG_FULL "$cfg"
      ensure_not_set CONFIG_LTO_NONE "$cfg"

      ensure_not_set CONFIG_CC_OPTIMIZE_FOR_SIZE "$cfg"

      # Prefer O3 if the kernel tree supports it, else O2
      if kconfig_has CC_OPTIMIZE_FOR_PERFORMANCE_O3; then
        ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE_O3 y "$cfg"
        ensure_not_set CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE "$cfg"
      else
        ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE y "$cfg"
      fi

      ensure_kconfig CONFIG_MODULE_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_MODULE_COMPRESS_ZSTD y "$cfg"
      ensure_kconfig CONFIG_LD_DEAD_CODE_DATA_ELIMINATION y "$cfg" || true
      ;;

    *)
      echo "[before.sh] Unknown KERNEL_OPT_PROFILE='$profile' (expected none|battery|balanced|performance)"
      return 1
      ;;
  esac
}

apply_kernel_profile "$KERNEL_OPT_PROFILE" "$DEFCONFIG_PATH"

# ---- Root integration (optional) ----
if [[ "$ROOT_METHOD" == "none" ]]; then
  echo "[before.sh] ROOT_METHOD=none -> skipping root integration."
  exit 0
fi

case "$ROOT_METHOD" in
  kernelsu)
    echo "[before.sh] Integrating KernelSU..."
    curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
    ensure_kconfig CONFIG_KSU y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPROBES y "$DEFCONFIG_PATH"
    ;;
  kernelsu-next)
    echo "[before.sh] Integrating KernelSU Next..."
    curl -LSs "https://raw.githubusercontent.com/KernelSU-Next/KernelSU-Next/next/kernel/setup.sh" | bash -
    ensure_kconfig CONFIG_KSU y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPROBES y "$DEFCONFIG_PATH"
    ;;
  sukisu-ultra)
    echo "[before.sh] Integrating SukiSU Ultra..."
    curl -LSs "https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh" | bash -s builtin
    ensure_kconfig CONFIG_KSU y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KSU_SYSCALL_HOOK y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPROBES y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KRETPROBES y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_HAVE_SYSCALL_TRACEPOINTS y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPM y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KALLSYMS y "$DEFCONFIG_PATH"
    ensure_not_set CONFIG_KSU_MANUAL_HOOK "$DEFCONFIG_PATH"
    ;;
  *)
    echo "[before.sh] Unknown ROOT_METHOD='$ROOT_METHOD'"
    exit 10
    ;;
esac

echo "[before.sh] Root integration done: $ROOT_METHOD"
EOF

  chmod 0755 "$USERSCRIPTS_DIR/before.sh"
  userscripts_assert_exec_mount
  [[ -x "$USERSCRIPTS_DIR/before.sh" ]] || { echo "ERROR: before.sh is not executable"; exit 4; }
}
