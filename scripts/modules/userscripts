#!/usr/bin/env bash
set -eo pipefail

userscripts_assert_exec_mount() {
  local dir="$1"
  
  # If findmnt isn't available, we can't reliably check.
  command -v findmnt >/dev/null 2>&1 || return 0

  # If the mount has noexec, executing before.sh from it will fail with "Permission denied".
  local opts
  opts="$(findmnt -no OPTIONS -T "$dir" 2>/dev/null || true)"
  if [[ "$opts" == *noexec* ]]; then
    die "Userscripts dir ($dir) is on a noexec mount (options: $opts). Move WORKDIR/userscripts to an exec-enabled filesystem."
  fi
}

userscripts_write_before_sh() {
  local file="$USERSCRIPTS_DIR/before.sh"

  cat > "$file" <<'BEOF'
#!/usr/bin/env bash
set -eo pipefail

echo "[before.sh] Running userscript..."

# --- Locate repo top ---------------------------------------------------------
TOP="$PWD"
if [[ ! -d "$TOP/.repo" ]]; then
  TOP="$(find /srv/src -maxdepth 6 -type d -name .repo -print -quit 2>/dev/null | xargs -r dirname)"
fi
if [[ -z "$TOP" || ! -d "$TOP/.repo" ]]; then
  echo "[before.sh] ERROR: Could not locate repo top (.repo). PWD=$PWD" >&2
  exit 1
fi

cd "$TOP"

echo "[before.sh] Repo top: $TOP"

# --- Patch known upstream build pitfalls ------------------------------------
# Some trees can end up with an empty/whitespace line in modules.order, and
# kernel/build/build.sh historically didn't guard against that (leading to
# 'basename: Needs 1 argument' and 'cp: Needs 2 arguments').
patch_kernel_build_scripts() {
  local f
  f="$(find "$TOP" -type f -path "*/kernel/build/build.sh" -print -quit 2>/dev/null || true)"
  [[ -f "$f" ]] || return 0

  if grep -q "skip empty modules.order lines" "$f"; then
    echo "[before.sh] kernel/build/build.sh already patched."
    return 0
  fi

  python3 - "$f" <<'PY'
import sys
from pathlib import Path

path = Path(sys.argv[1])
text = path.read_text(errors="ignore")
marker = "skip empty modules.order lines"
if marker in text:
    sys.exit(0)

import re

pattern = re.compile(r'^\s*\[\[\s*"\$\{?ko\}?"\s*=\s*\\#\*\s*\]\]\s*&&\s*continue\s*$', re.M)
m = pattern.search(text)
if not m:
    # File layout changed; don't risk patching the wrong place.
    sys.exit(0)

line = m.group(0)
text = text.replace(
    line,
    line + "\n    [[ -z \"${ko}\" ]] && continue  # " + marker,
    1,
)
path.write_text(text)
PY

  if grep -q "skip empty modules.order lines" "$f"; then
    echo "[before.sh] Patched: $f"
  else
    echo "[before.sh] NOTE: kernel/build/build.sh found but patch did not apply (layout changed)." >&2
  fi
}

patch_kernel_build_scripts

# --- Custom apps injection ---------------------------------------------------
# Always clear a previously injected vendor/custom_apps (so disabling custom apps
# actually removes them on the next build). Do NOT delete if it's a real repo.
if [[ -d "$TOP/vendor/custom_apps" && ! -e "$TOP/vendor/custom_apps/.git" ]]; then
  echo "[before.sh] Clearing injected vendor/custom_apps..."
  rm -rf "$TOP/vendor/custom_apps"
fi

if [[ -d /srv/custom_apps/vendor/custom_apps ]]; then
  echo "[before.sh] Installing custom apps (vendor/custom_apps)..."
  mkdir -p "$TOP/vendor"
  cp -a /srv/custom_apps/vendor/custom_apps "$TOP/vendor/custom_apps"
fi

# --- Optional: remove FDroid from microG partner_gms -------------------------
# NOTE: This is best-effort and intentionally limited to partner_gms product
# files. It can still break if upstream changes.
if [[ "${REPLACE_STOCK_FDROID:-false}" == "true" ]]; then
  echo "[before.sh] REPLACE_STOCK_FDROID=true (best-effort)"

  for gmsdir in "$TOP/vendor/partner_gms" "$TOP/vendor/partner_gms-tv" "$TOP/vendor/partner_gms-car"; do
    [[ -d "$gmsdir" ]] || continue

    echo "[before.sh]  - Removing FDroid from: ${gmsdir#$TOP/}"

    if [[ -d "$gmsdir/products" ]]; then
      # Remove standalone list entries (common style: one package per line).
      for token in FDroid FDroidPrivilegedExtension F-Droid F-DroidPrivilegedExtension; do
        find "$gmsdir/products" -type f \( -name "*.mk" -o -name "*.xml" \) -print0 2>/dev/null \
          | xargs -0 -r sed -i -E \
              -e "/^[[:space:]]*${token}[[:space:]]*(\\\\)?[[:space:]]*$/d"
      done
    fi

    # If the repo uses top-level module dirs (like android_vendor_partner_gms),
    # remove them so they're not parsed.
    rm -rf "$gmsdir/FDroid" "$gmsdir/FDroidPrivilegedExtension" \
           "$gmsdir/F-Droid" "$gmsdir/F-DroidPrivilegedExtension" || true
  done
fi

# --- Kernel defconfig helpers ------------------------------------------------
ensure_kconfig() {
  local file="$1"
  local key="$2"
  local val="$3"

  if grep -qE "^${key}=" "$file"; then
    sed -i "s|^${key}=.*|${key}=${val}|" "$file"
  elif grep -qE "^# ${key} is not set" "$file"; then
    sed -i "s|^# ${key} is not set|${key}=${val}|" "$file"
  else
    echo "${key}=${val}" >> "$file"
  fi
}

ensure_not_set() {
  local file="$1"
  local key="$2"

  if grep -qE "^${key}=" "$file"; then
    sed -i "s|^${key}=.*|# ${key} is not set|" "$file"
  elif ! grep -qE "^# ${key} is not set" "$file"; then
    echo "# ${key} is not set" >> "$file"
  fi
}

locate_defconfig() {
  local device="$1"

  # Known-ish patterns (GKI vendor configs are common on modern devices)
  local patterns=(
    "*/arch/arm64/configs/vendor/${device}_GKI.config"
    "*/arch/arm64/configs/vendor/${device}_defconfig"
    "*/arch/arm64/configs/${device}_defconfig"
    "*/arch/arm64/configs/${device}_GKI_defconfig"
  )

  local p
  for p in "${patterns[@]}"; do
    local hit
    hit="$(find . -type f -path "$p" -print -quit 2>/dev/null || true)"
    if [[ -n "$hit" ]]; then
      echo "$hit"
      return 0
    fi
  done

  # Fallback: find any vendor config containing the device name.
  find . -type f -path "*/arch/arm64/configs/*" 2>/dev/null \
    | awk -v d="$device" 'tolower($0) ~ tolower(d) { print; exit }'
}

# Device used for kernel tuning/root integration.
DEVICE="${DEVICE_LIST:-}"
if [[ -z "$DEVICE" ]]; then
  echo "[before.sh] NOTE: DEVICE_LIST not set; skipping kernel optimization/root integration." >&2
  exit 0
fi

KCONF="$(locate_defconfig "$DEVICE" || true)"
if [[ -z "$KCONF" ]]; then
  echo "[before.sh] ERROR: Could not locate a defconfig/vendor config for device '$DEVICE'." >&2
  echo "[before.sh] Hint: ensure device sources are present (breakfast may be required)." >&2
  exit 1
fi

echo "[before.sh] Found kernel config: $KCONF"

# Determine kernel git project root robustly.
KCONF_DIR="$(dirname "$KCONF")"
if git -C "$KCONF_DIR" rev-parse --show-toplevel >/dev/null 2>&1; then
  KERNEL_DIR="$(git -C "$KCONF_DIR" rev-parse --show-toplevel)"
else
  # Fallback (assumes vendor-style path .../arch/arm64/configs/vendor/<file>)
  KERNEL_DIR="$(realpath "$KCONF_DIR/../../../..")"
fi

DEFCONFIG="$(basename "$KCONF")"
OUT_DIR="$KERNEL_DIR/out"

# Export for any setup scripts we run *inside this userscript*.
export KERNEL_DIR ARCH=arm64 DEFCONFIG OUT_DIR

echo "[before.sh] Kernel dir: $KERNEL_DIR"

echo "[before.sh] Resetting kernel tree to a clean state before applying changes..."
cd "$KERNEL_DIR"
if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  git reset --hard
  git clean -fdx
fi

# --- Kernel optimization profiles -------------------------------------------
apply_kernel_profile() {
  local profile="$1"
  local defcfg="$2"

  echo "[before.sh] Applying kernel optimization profile: $profile"

  case "$profile" in
    battery)
      ensure_kconfig "$defcfg" CONFIG_LTO_CLANG y
      ensure_kconfig "$defcfg" CONFIG_LTO_CLANG_THIN y
      ensure_not_set "$defcfg" CONFIG_LTO_CLANG_FULL

      ensure_kconfig "$defcfg" CONFIG_CC_OPTIMIZE_FOR_SIZE y

      ensure_not_set "$defcfg" CONFIG_DEBUG_INFO
      ensure_not_set "$defcfg" CONFIG_KALLSYMS
      ensure_not_set "$defcfg" CONFIG_KALLSYMS_ALL

      ensure_kconfig "$defcfg" CONFIG_ZRAM m
      ensure_kconfig "$defcfg" CONFIG_ZSMALLOC y

      ensure_kconfig "$defcfg" CONFIG_MODULE_COMPRESS y
      ensure_kconfig "$defcfg" CONFIG_MODULE_COMPRESS_ZSTD y
      ;;

    balanced)
      ensure_kconfig "$defcfg" CONFIG_LTO_CLANG y
      ensure_kconfig "$defcfg" CONFIG_LTO_CLANG_THIN y
      ensure_not_set "$defcfg" CONFIG_LTO_CLANG_FULL

      ensure_kconfig "$defcfg" CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE y

      ensure_not_set "$defcfg" CONFIG_DEBUG_INFO

      ensure_kconfig "$defcfg" CONFIG_ZRAM m
      ensure_kconfig "$defcfg" CONFIG_ZSMALLOC y
      ;;

    performance)
      ensure_kconfig "$defcfg" CONFIG_LTO_CLANG y
      ensure_kconfig "$defcfg" CONFIG_LTO_CLANG_FULL y
      ensure_not_set "$defcfg" CONFIG_LTO_CLANG_THIN

      ensure_kconfig "$defcfg" CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE y

      ensure_kconfig "$defcfg" CONFIG_ZRAM m
      ensure_kconfig "$defcfg" CONFIG_ZSMALLOC y
      ;;

    none)
      echo "[before.sh] Kernel optimization disabled."
      ;;

    *)
      echo "[before.sh] Unknown kernel profile: $profile (skipping)" >&2
      ;;
  esac
}

KPROFILE="${KERNEL_OPT_PROFILE:-none}"
apply_kernel_profile "$KPROFILE" "$KCONF"

# --- Root integration --------------------------------------------------------
# NOTE:
#  - These upstream setup scripts can and do change.
#  - If you see build failures after enabling a root method, try:
#      1) ROOT_METHOD=none (confirm build works)
#      2) Switch root method, or pin a known-good tag/commit.
ROOT_METHOD_CHOICE="${ROOT_METHOD:-none}"

apply_sukisu_patchset() {
  local repo_url="https://github.com/SukiSU-Ultra/SukiSU_patch"
  local tmpdir
  tmpdir="$(mktemp -d)"

  echo "[before.sh] Applying SukiSU patchset (best-effort)..."
  if git clone --depth 1 "$repo_url" "$tmpdir" >/dev/null 2>&1; then
    if [[ -f "$tmpdir/patches/69_hide_stuff.patch" ]]; then
      patch -p1 --forward --fuzz=3 < "$tmpdir/patches/69_hide_stuff.patch" || true
    fi
  else
    echo "[before.sh] NOTE: Could not clone SukiSU patch repo; skipping patchset." >&2
  fi

  rm -rf "$tmpdir"
}

case "$ROOT_METHOD_CHOICE" in
  kernelsu)
    echo "[before.sh] Integrating KernelSU (builtin)..."
    curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
    ;;

  kernelsu-next)
    echo "[before.sh] Integrating KernelSU-Next (builtin)..."
    curl -LSs "https://raw.githubusercontent.com/KernelSU-Next/KernelSU-Next/next/kernel/setup.sh" | bash -
    ;;

  sukisu-ultra)
    echo "[before.sh] Integrating SukiSU-Ultra (builtin)..."
    curl -LSs "https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh" | bash -s builtin

    # SukiSU KPM
    ensure_kconfig "$KCONF" CONFIG_KPM y

    apply_sukisu_patchset
    ;;

  none)
    echo "[before.sh] Root integration disabled."
    ;;

  *)
    echo "[before.sh] Unknown ROOT_METHOD='$ROOT_METHOD_CHOICE' (skipping)." >&2
    ;;
esac

echo "[before.sh] Done."
exit 0
BEOF

  chmod 0755 "$file"

  userscripts_assert_exec_mount "$USERSCRIPTS_DIR"

  [[ -x "$file" ]] || die "before.sh not executable at $file"
}
