#!/usr/bin/env bash
set -eo pipefail

# Generate docker-lineage-cicd userscripts.
#
# Hook order (per docker-lineage-cicd outline):
#   repo init/sync -> prepare env -> before.sh -> breakfast -> pre-build.sh -> mka -> post-build.sh
#
# Key rule:
#   - before.sh runs BEFORE breakfast, so device/kernel repos may NOT exist yet.
#   - Anything requiring defconfig/kernel tree must run in pre-build.sh.
#   - To avoid future 'repo sync' failures due to dirty repos, post-build.sh resets modified repos.

userscripts_assert_exec_mount() {
  if command -v findmnt >/dev/null 2>&1; then
    local opts
    opts="$(findmnt -no OPTIONS -T "$USERSCRIPTS_DIR" 2>/dev/null || true)"
    if echo "$opts" | grep -qw noexec; then
      echo "ERROR: USERSCRIPTS_DIR is on a 'noexec' mount: $USERSCRIPTS_DIR"
      echo "Mount options: $opts"
      echo "Move this repo/workdir somewhere executable (or remount without noexec)."
      exit 3
    fi
  fi
}

userscripts_write_before_sh() {
  # ---------------------------------------------------------------------------
  # before.sh (runs BEFORE breakfast)
  # ---------------------------------------------------------------------------
  cat > "$USERSCRIPTS_DIR/before.sh" <<'EOS'
#!/usr/bin/env bash
set -eo pipefail

# Find repo top
TOP="$PWD"
if [[ ! -d "$TOP/.repo" ]]; then
  TOP="$(find /srv/src -maxdepth 6 -type d -name .repo -print -quit 2>/dev/null | xargs -r dirname)"
fi
if [[ -z "$TOP" || ! -d "$TOP/.repo" ]]; then
  echo "[before.sh] ERROR: Could not locate repo top (.repo). PWD=$PWD"
  echo "[before.sh] Contents of /srv/src:"
  ls -la /srv/src || true
  exit 2
fi
cd "$TOP"

# ---- Custom system apps (best-effort) ----
# If you previously injected vendor/custom_apps, remove it so "disabled" really means disabled.
if [[ -d "$TOP/vendor/custom_apps" && ! -d "$TOP/vendor/custom_apps/.git" ]]; then
  rm -rf "$TOP/vendor/custom_apps" || true
fi

if [[ -d /srv/custom_apps/vendor/custom_apps ]]; then
  echo "[before.sh] Installing custom apps into vendor/custom_apps..."
  mkdir -p "$TOP/vendor"
  cp -a /srv/custom_apps/vendor/custom_apps "$TOP/vendor/" || true
fi

# ---- (Optional) replace stock FDroid that comes from vendor/partner_gms ----
: "${REPLACE_STOCK_FDROID:=false}"

remove_fdroid_from_partner_dir() {
  local dir="$1"
  [[ -d "$dir" ]] || return 0

  echo "[before.sh] - Removing FDroid from: ${dir#$TOP/}"

  remove_token() {
    local token="$1"
    local files

    files="$(grep -RIl \
      --include='*.mk' --include='*.xml' \
      --exclude-dir='FDroid' \
      --exclude-dir='F-Droid' \
      --exclude-dir='FDroidPrivilegedExtension' \
      --exclude-dir='F-DroidPrivilegedExtension' \
      "$token" "$dir" 2>/dev/null || true)"

    [[ -n "$files" ]] || return 0

    while IFS= read -r f; do
      sed -i \
        -e "s/[[:space:]]\b${token}\b[[:space:]]*/ /g" \
        -e "s/[[:space:]]\{2,\}/ /g" \
        "$f" || true
    done <<<"$files"
  }

  remove_token "FDroid"
  remove_token "FDroidPrivilegedExtension"
  remove_token "F-Droid"
  remove_token "F-DroidPrivilegedExtension"

  # Delete the module directories so their Android.mk never gets parsed
  rm -rf \
    "$dir/FDroid" \
    "$dir/F-Droid" \
    "$dir/FDroidPrivilegedExtension" \
    "$dir/F-DroidPrivilegedExtension" \
    || true
}

if [[ "$REPLACE_STOCK_FDROID" == "true" ]]; then
  echo "[before.sh] REPLACE_STOCK_FDROID=true (best-effort)"
  remove_fdroid_from_partner_dir "$TOP/vendor/partner_gms"
  remove_fdroid_from_partner_dir "$TOP/vendor/partner_gms-tv"
  remove_fdroid_from_partner_dir "$TOP/vendor/partner_gms-car"
fi

# ---- Safety patch: skip empty lines in modules.order (prevents basename/cp style fallout in some setups) ----
# This lives in platform/kernel/build. We patch it here because it exists before breakfast.
patch_kernel_build_modules_order() {
  local f
  f="$(find "$TOP" -type f -path '*/kernel/build/build.sh' -print -quit 2>/dev/null || true)"
  [[ -n "$f" ]] || return 0

  # Only patch once
  if grep -q "LINEAGEOS_DOCKERBUILDSCRIPT_PATCH_modules_order" "$f" 2>/dev/null; then
    return 0
  fi

  echo "[before.sh] Patching kernel/build/build.sh to skip empty lines in modules.order"

  # Insert after the comment/blank/\# skip checks inside the modules.order loop.
  python3 - <<'PY' "$f" || true
import re, sys
path = sys.argv[1]
with open(path, 'r', encoding='utf-8', errors='ignore') as fh:
    lines = fh.readlines()

out = []
inserted = False
for i, line in enumerate(lines):
    out.append(line)

    # Heuristic: find the modules.order loop and inject after "skip comments" handling.
    if not inserted and re.search(r"modules\.order", line) and re.search(r"while\s+read", line):
        # keep scanning; injection point a few lines later
        continue

    if not inserted and re.search(r"\[\[\s+\"\$ko\"\s+=\s+\#\*\s+\]\]", line):
        out.append("\n")
        out.append("    # LINEAGEOS_DOCKERBUILDSCRIPT_PATCH_modules_order\n")
        out.append("    # Some setups can emit empty lines in modules.order; skip them to avoid basename/cp errors.\n")
        out.append("    [[ -z \"$ko\" ]] && continue\n")
        inserted = True

if not inserted:
    # fallback: no change
    sys.exit(0)

with open(path, 'w', encoding='utf-8') as fh:
    fh.writelines(out)
PY
}

patch_kernel_build_modules_order

echo "[before.sh] Done. (Kernel/root patching happens in pre-build.sh after breakfast.)"
exit 0
EOS

  # ---------------------------------------------------------------------------
  # pre-build.sh (runs AFTER breakfast)
  # ---------------------------------------------------------------------------
  cat > "$USERSCRIPTS_DIR/pre-build.sh" <<'EOS'
#!/usr/bin/env bash
set -eo pipefail

echo "[pre-build.sh] Running (after breakfast)..."

# Find repo top
TOP="$PWD"
if [[ ! -d "$TOP/.repo" ]]; then
  TOP="$(find /srv/src -maxdepth 6 -type d -name .repo -print -quit 2>/dev/null | xargs -r dirname)"
fi
if [[ -z "$TOP" || ! -d "$TOP/.repo" ]]; then
  echo "[pre-build.sh] ERROR: Could not locate repo top (.repo). PWD=$PWD"
  exit 2
fi
cd "$TOP"

echo "[pre-build.sh] Repo top: $TOP"

device_from_device_list() {
  local dl="${DEVICE_LIST:-}"
  dl="${dl// /,}"
  dl="${dl%%,*}"
  echo "$dl"
}

DEV="${DEVICE:-}"
[[ -n "$DEV" ]] || DEV="$(device_from_device_list)"
if [[ -z "$DEV" ]]; then
  echo "[pre-build.sh] ERROR: DEVICE/DEVICE_LIST not set"
  exit 3
fi

echo "[pre-build.sh] Device: $DEV"

: "${ROOT_METHOD:=none}"
: "${KERNEL_OPT_PROFILE:=battery}"

ensure_kconfig() {
  local key="$1" val="$2" file="$3"
  sed -i -E "/^${key}=.*/d; /^# ${key} is not set/d" "$file"
  echo "${key}=${val}" >> "$file"
}

ensure_not_set() {
  local key="$1" file="$2"
  sed -i -E "/^${key}=.*/d; /^# ${key} is not set/d" "$file"
  echo "# ${key} is not set" >> "$file"
}

kconfig_has() {
  local sym="$1"
  grep -Rqs --include='Kconfig*' "^[[:space:]]*config[[:space:]]\+${sym}\b" . 2>/dev/null
}

locate_defconfig() {
  local device="$1"
  local p hit

  for p in \
    "*/arch/arm64/configs/vendor/${device}_GKI.config" \
    "*/arch/arm64/configs/vendor/${device}.config" \
    "*/arch/arm64/configs/vendor/${device}_defconfig" \
    "*/arch/arm64/configs/${device}_defconfig"
  do
    hit="$(find . -type f -path "$p" -print -quit 2>/dev/null || true)"
    [[ -n "$hit" ]] && { echo "$hit"; return 0; }
  done

  return 1
}

KCONF="$(locate_defconfig "$DEV" || true)"
if [[ -z "$KCONF" ]]; then
  echo "[pre-build.sh] ERROR: Could not locate defconfig for device '$DEV' AFTER breakfast."
  echo "[pre-build.sh] Hint: device repos may be missing or codename mismatch."
  exit 4
fi

KCONF_DIR="$(dirname "$KCONF")"
KERNEL_DIR="$(git -C "$KCONF_DIR" rev-parse --show-toplevel 2>/dev/null || true)"
if [[ -z "$KERNEL_DIR" ]]; then
  KERNEL_DIR="$(realpath "$KCONF_DIR/../../../..")"
fi

DEFCONFIG_PATH="$(realpath "$KCONF")"

echo "[pre-build.sh] Kernel dir:  $KERNEL_DIR"
echo "[pre-build.sh] Defconfig:   $DEFCONFIG_PATH"
echo "[pre-build.sh] Opt profile: $KERNEL_OPT_PROFILE"
echo "[pre-build.sh] Root method: $ROOT_METHOD"

# Export vars expected by some KernelSU/SukiSU scripts
export KERNEL_DIR
export ARCH=arm64
export DEFCONFIG="$(basename "$DEFCONFIG_PATH")"
export OUT_DIR="$KERNEL_DIR/out"

cd "$KERNEL_DIR"

# Keep kernel repo clean between runs
if command -v git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  git reset --hard
  git clean -fdx
fi

apply_kernel_profile() {
  local profile="$1" cfg="$2"

  case "$profile" in
    none)
      echo "[pre-build.sh] KERNEL_OPT_PROFILE=none -> skipping."
      return 0
      ;;

    battery)
      echo "[pre-build.sh] Applying battery-leaning kernel optimizations..."

      ensure_kconfig CONFIG_LTO_CLANG y "$cfg"
      ensure_kconfig CONFIG_LTO_CLANG_THIN y "$cfg"
      ensure_not_set CONFIG_LTO_CLANG_FULL "$cfg"
      ensure_not_set CONFIG_LTO_NONE "$cfg"

      ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_SIZE y "$cfg"

      ensure_kconfig CONFIG_ZSMALLOC y "$cfg"
      ensure_kconfig CONFIG_ZRAM m "$cfg"
      ensure_kconfig CONFIG_CRYPTO_ZSTD y "$cfg"
      ensure_kconfig CONFIG_ZSTD_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_ZSTD_DECOMPRESS y "$cfg"

      ensure_kconfig CONFIG_MODULE_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_MODULE_COMPRESS_ZSTD y "$cfg"

      ensure_not_set CONFIG_DEBUG_INFO "$cfg"
      ensure_not_set CONFIG_GCOV_KERNEL "$cfg"
      ensure_not_set CONFIG_KASAN "$cfg"
      ensure_not_set CONFIG_KCSAN "$cfg"
      ensure_not_set CONFIG_KFENCE "$cfg"
      ensure_not_set CONFIG_DEBUG_KERNEL "$cfg"

      ensure_kconfig CONFIG_LD_DEAD_CODE_DATA_ELIMINATION y "$cfg" || true
      ensure_kconfig CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL y "$cfg" || true
      ;;

    balanced)
      echo "[pre-build.sh] Applying balanced kernel optimizations..."

      ensure_kconfig CONFIG_LTO_CLANG y "$cfg"
      ensure_kconfig CONFIG_LTO_CLANG_THIN y "$cfg"
      ensure_not_set CONFIG_LTO_CLANG_FULL "$cfg"
      ensure_not_set CONFIG_LTO_NONE "$cfg"

      ensure_not_set CONFIG_CC_OPTIMIZE_FOR_SIZE "$cfg"
      ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE y "$cfg"

      ensure_kconfig CONFIG_ZSMALLOC y "$cfg"
      ensure_kconfig CONFIG_ZRAM m "$cfg"
      ensure_kconfig CONFIG_CRYPTO_ZSTD y "$cfg"
      ensure_kconfig CONFIG_ZSTD_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_ZSTD_DECOMPRESS y "$cfg"

      ensure_kconfig CONFIG_MODULE_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_MODULE_COMPRESS_ZSTD y "$cfg"

      ensure_kconfig CONFIG_LD_DEAD_CODE_DATA_ELIMINATION y "$cfg" || true
      ;;

    performance)
      echo "[pre-build.sh] Applying performance kernel optimizations (ThinLTO + O3 if available)..."

      ensure_kconfig CONFIG_LTO_CLANG y "$cfg"
      ensure_kconfig CONFIG_LTO_CLANG_THIN y "$cfg"
      ensure_not_set CONFIG_LTO_CLANG_FULL "$cfg"
      ensure_not_set CONFIG_LTO_NONE "$cfg"

      ensure_not_set CONFIG_CC_OPTIMIZE_FOR_SIZE "$cfg"

      if kconfig_has CC_OPTIMIZE_FOR_PERFORMANCE_O3; then
        ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE_O3 y "$cfg"
        ensure_not_set CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE "$cfg"
      else
        ensure_kconfig CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE y "$cfg"
      fi

      ensure_kconfig CONFIG_MODULE_COMPRESS y "$cfg"
      ensure_kconfig CONFIG_MODULE_COMPRESS_ZSTD y "$cfg"
      ensure_kconfig CONFIG_LD_DEAD_CODE_DATA_ELIMINATION y "$cfg" || true
      ;;

    *)
      echo "[pre-build.sh] Unknown KERNEL_OPT_PROFILE='$profile' (expected none|battery|balanced|performance)"
      return 1
      ;;
  esac
}

apply_kernel_profile "$KERNEL_OPT_PROFILE" "$DEFCONFIG_PATH"

# ---- Root integration (optional) ----
if [[ "$ROOT_METHOD" == "none" ]]; then
  echo "[pre-build.sh] ROOT_METHOD=none -> skipping root integration."
  exit 0
fi

case "$ROOT_METHOD" in
  kernelsu)
    echo "[pre-build.sh] Integrating KernelSU..."
    curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
    ensure_kconfig CONFIG_KSU y "$DEFCONFIG_PATH"
    ensure_not_set CONFIG_KSU_DEBUG "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPROBES y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KRETPROBES y "$DEFCONFIG_PATH"
    ;;
  kernelsu-next)
    echo "[pre-build.sh] Integrating KernelSU Next..."
    curl -LSs "https://raw.githubusercontent.com/KernelSU-Next/KernelSU-Next/next/kernel/setup.sh" | bash -
    ensure_kconfig CONFIG_KSU y "$DEFCONFIG_PATH"
    ensure_not_set CONFIG_KSU_DEBUG "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPROBES y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KRETPROBES y "$DEFCONFIG_PATH"
    ;;
  sukisu-ultra)
    echo "[pre-build.sh] Integrating SukiSU Ultra..."
    curl -LSs "https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh" | bash -s builtin
    ensure_kconfig CONFIG_KSU y "$DEFCONFIG_PATH"
    ensure_not_set CONFIG_KSU_DEBUG "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPROBES y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KRETPROBES y "$DEFCONFIG_PATH"
    ensure_kconfig CONFIG_KPM y "$DEFCONFIG_PATH"
    ;;
  *)
    echo "[pre-build.sh] Unknown ROOT_METHOD='$ROOT_METHOD'"
    exit 10
    ;;
esac

echo "[pre-build.sh] Root integration done: $ROOT_METHOD"
EOS

  # ---------------------------------------------------------------------------
  # post-build.sh (runs AFTER build; runs even on many failure paths)
  # Goal: keep repos clean so the next run's 'repo sync' doesn't fail.
  # ---------------------------------------------------------------------------
  cat > "$USERSCRIPTS_DIR/post-build.sh" <<'EOS'
#!/usr/bin/env bash
set -eo pipefail

echo "[post-build.sh] Cleaning modified repos to keep repo sync happy..."

TOP="$PWD"
if [[ ! -d "$TOP/.repo" ]]; then
  TOP="$(find /srv/src -maxdepth 6 -type d -name .repo -print -quit 2>/dev/null | xargs -r dirname)"
fi
if [[ -z "$TOP" || ! -d "$TOP/.repo" ]]; then
  echo "[post-build.sh] WARN: Could not locate repo top; skipping."
  exit 0
fi
cd "$TOP"

reset_repo_if_dirty() {
  local dir="$1"
  [[ -d "$dir" ]] || return 0
  command -v git >/dev/null 2>&1 || return 0

  if git -C "$dir" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    if [[ -n "$(git -C "$dir" status --porcelain 2>/dev/null || true)" ]]; then
      echo "[post-build.sh] Resetting: ${dir#$TOP/}"
      git -C "$dir" reset --hard || true
      git -C "$dir" clean -fdx || true
    fi
  fi
}

# vendor/partner_gms* may be edited for FDroid removal
reset_repo_if_dirty "$TOP/vendor/partner_gms"
reset_repo_if_dirty "$TOP/vendor/partner_gms-tv"
reset_repo_if_dirty "$TOP/vendor/partner_gms-car"

# platform/kernel/build may be patched
reset_repo_if_dirty "$TOP/kernel/build"

# Device kernel tree may be patched (try to locate via defconfig)
DEV="${DEVICE:-}"
if [[ -z "$DEV" && -n "${DEVICE_LIST:-}" ]]; then
  DEV="${DEVICE_LIST// /,}"
  DEV="${DEV%%,*}"
fi

if [[ -n "$DEV" ]]; then
  KCONF="$(find "$TOP" -type f -path "*/arch/arm64/configs/vendor/${DEV}_GKI.config" -print -quit 2>/dev/null || true)"
  if [[ -n "$KCONF" ]]; then
    KERNEL_DIR="$(git -C "$(dirname "$KCONF")" rev-parse --show-toplevel 2>/dev/null || true)"
    [[ -n "$KERNEL_DIR" ]] && reset_repo_if_dirty "$KERNEL_DIR"
  fi
fi

# Remove injected custom apps dir so "disabled" stays disabled next run
if [[ -d "$TOP/vendor/custom_apps" && ! -d "$TOP/vendor/custom_apps/.git" ]]; then
  rm -rf "$TOP/vendor/custom_apps" || true
fi

echo "[post-build.sh] Done."
exit 0
EOS

  chmod 0755 "$USERSCRIPTS_DIR/before.sh" "$USERSCRIPTS_DIR/pre-build.sh" "$USERSCRIPTS_DIR/post-build.sh"

  userscripts_assert_exec_mount
  [[ -x "$USERSCRIPTS_DIR/before.sh" ]] || { echo "ERROR: before.sh is not executable"; exit 4; }
  [[ -x "$USERSCRIPTS_DIR/pre-build.sh" ]] || { echo "ERROR: pre-build.sh is not executable"; exit 4; }
  [[ -x "$USERSCRIPTS_DIR/post-build.sh" ]] || { echo "ERROR: post-build.sh is not executable"; exit 4; }
}
